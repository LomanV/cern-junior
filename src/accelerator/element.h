#pragma once

#include <functional> // for std::function
#include <vector>
#include <cmath> // for isinf

#include "../general/exceptions.h"
#include "../vector3d/vector3d.h"
#include "../physics/particle.h"

typedef std::function<double(const Vector3D &)> ScalarField;
typedef std::function<Vector3D(const Vector3D &)> VectorField; 

class Element{
	protected:
		Vector3D entry_point; // entry position
		Vector3D exit_point; // exit position

		double radius; // radius of the vaccum chamber
		double curvature; // radial curvature (potentially zero)

		Element* successor; // points to the following element

		std::vector<Particle*> particle_list; // list of particles contained inside

		bool is_straight(void) const;

	public:
		Element(const Vector3D& entry, const Vector3D& exit, double my_radius, double my_curvature, Element* my_successor) :
			entry_point(entry),
			exit_point(exit),
			radius(my_radius),
			curvature(my_curvature),
			successor(my_successor)
		{}

		virtual ~Element(void){}

		Vector3D direction(void) const;

		virtual std::ostream& print(std::ostream& output) const;
		// Base method prints only basic information (i.e. about its shape)
		// Subclass overrides will add additional information e.g. type of the element, electric/magnetic fields, other parameters...

		void link(Element &next_element);	

		Vector3D center(void) const; // returns the center of circular element assuming curvature is non-zero

		bool has_collided(const Particle& p) const; // returns true iff p has collided with the element's edge
		bool has_left(const Particle& p) const; // returns true iff p has passed to the next element
		
		virtual void add_lorentz_force(Particle &p, double dt) const = 0;
}; 

std::ostream& operator<<(std::ostream& output, const Element &E);

class Straight_element : public Element{
	public:
		Straight_element(const Vector3D& entry, const Vector3D& exit, double my_radius, Element* my_successor) :
			Element(entry,exit,my_radius,0.0,my_successor)
		{}
		virtual ~Straight_element(void) override{}
		virtual void add_lorentz_force(Particle& p, double dt) const override{ return; } // no force fields
};

class Electric_element : public Element{
	protected:
		VectorField E; // electric field
	public:
		Electric_element(const Vector3D& entry, const Vector3D& exit, double my_radius, double my_curvature, Element* my_successor, VectorField electric_field) :
			Element(entry,exit,my_radius,my_curvature,my_successor),
			E(electric_field)
		{}
		virtual ~Electric_element(void) override{}
		virtual void add_lorentz_force(Particle& p, double dt) const override;
};

class Magnetic_element : public Element{
	protected:
		VectorField B; // magnetic field
	public:
		Magnetic_element(const Vector3D& entry, const Vector3D& exit, double my_radius, double my_curvature, Element* my_successor, VectorField magnetic_field) :
			Element(entry,exit,my_radius,my_curvature,my_successor),
			B(magnetic_field)
		{}
		virtual ~Magnetic_element(void) override{}
		virtual void add_lorentz_force(Particle& p, double dt) const override;
};

class Dipole : public Magnetic_element{
	private:
		double B_0; // constant amplitude of the magnetic field generated by the dipole
	public:
		virtual std::ostream& print(std::ostream& output) const override;

		Dipole(const Vector3D& entry, const Vector3D& exit, double my_radius, double my_curvature, Element* my_successor, double my_B_0) :
			Magnetic_element(
				entry, exit, my_radius, my_curvature, my_successor,
				[&](const Vector3D &){ return my_B_0*basicvector::Z_VECTOR; } // this lambda returns a constant magnetic field determined by B_0
			)
		{
			if(is_straight()) throw excptn::ZERO_CURVATURE_DIPOLE;
		}
};

class Quadrupole : public Magnetic_element{
	private:
		double b; // parameter of the quadrupole
	public:
		virtual std::ostream& print(std::ostream& output) const override;

		Quadrupole(const Vector3D& entry, const Vector3D& exit, double my_radius, double my_curvature, Element* my_successor, double my_b) :
			Magnetic_element(
				entry, exit, my_radius, my_curvature, my_successor,
				[&](const Vector3D &v){
					Vector3D d((exit_point - entry_point).unitary());
					Vector3D y(v - (v|d)*v);
					Vector3D u(basicvector::Z_VECTOR ^ d);
					return b*((y|u)*basicvector::Z_VECTOR + v[2]*u);
				}
			){}
};
