\documentclass[12pt, letterpaper, twoside]{article}
\usepackage[top=3cm, bottom=3cm, left=3cm, right=3cm]{geometry}
\usepackage[fleqn]{amsmath}
\usepackage{amssymb}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}

\title{Projet : fichier réponses}
\author{Raphaël Vock, Lomàn Vezin}

\newcommand{\T}[1]{\texttt{#1}}
\newcommand{\V}[0]{\texttt{Vector3D}}
\newcommand{\double}{\texttt{double}}

\begin{document}
\maketitle
\section{La classe \T{Vector3D}}
\subsection{Conception}
\noindent \textbf{(P1.1)} Les points et vecteurs de l'espace euclidien sont représentés au moyen de la classe \V\ dont les attributs \T{x}, \T{y}, \T{z} (de type \double) représentent les coordonnées cartésiennes d'une instance. Celles-ci sont des attributs privés, mais tout le reste est publique. Voici les opérations que nous avons implémentées en premier :

\begin{itemize}

\item \T{getCoords()}  est une méthode qui retourne les coordonnées d'une instance via un \T{std::array<double,3>}.

\item \T{norm()} et \T{norm2()} retournent la norme euclidienne (resp. norme euclidienne au carré).

\item \T{distance(x,y)} et \T{distance2(x,y)} sont des méthodes statiques qui retournent la distance euclidienne (resp. distance euclidienne au carré) entre les deux arguments.

\item \T{unitary()} est une méthode qui retourne le vecteur directeur de même sens et de même direction (et lance une exception si l'instance est le vecteur nul ; voir point suivant).

\item \T{is\_zero()} est une méthode qui retourne un bool indiquant si l'instance est plus petite (en norme au carré) qu'une (petite) constante de classe \T{EPSILON} de type \double.
\end{itemize}

\subsection{Constructeur, constructeur de copie}
\noindent \textbf{(P4.1)} L'unique constructeur de la classe prend en argument trois \double\ (nuls par défaut) et initialise un \V\ avec les coordonnées cartésiennes précisées. En l'absence d'attributs pointeurs, le constructeur de copie minimal par défaut réalise exactement ce que l'on attend, donc \textbf{nous n'avons pas défini de constructeur de copie.}

\subsection{Coordonnées sphériques}
\noindent \textbf{(P4.2)} \textbf{Nous n’avons pas implémenté de constructeur en coordonnées sphériques.} Avant tout, l’ajout de ce dernier serait un peu technique au niveau du prototypage de car nous aurions \textit{a priori} deux constructeurs aux protoypes identiques. Ce n'est pas un problème incontournable ; on pourrait, par exemple, écrire un seul et unique constructeur dont le quatrième argument est un \T{bool} (\T{false} par défaut) qui précise si les arguments donnés doivent être compris comme des coordonnées sphériques ou sinon cartésiennes.

Mais le problème fondamental est le suivant : un repère sphérique est intextricablement lié à la donnée d'un point $O$ considéré comme l'origine. Pour écrire un constructeur sphérique sans ambiguité il serait donc nécessaire :
\begin{itemize}
\item ou bien de faire un choix canonique de $O$ qui ne changerait pas du début à la fin
\item ou bien de préciser $O$ en le passant comme argument.
\end{itemize}
Si l'on choisit la première option, l'unique avantage des sphériques serait perdue car on ne serait plus en mesure de choisir l'origine à notre gré pour simplifier, entre autres, des expressions de force (e.g. en choisissant $O$ l'origine d'un champ de force central). Mais la deuxième option serait coûteuse à implémenter et lourde à utiliser, pour des avantages qui finalement n'en vaudraient pas le coup.

\subsection{Surcharge des opérateurs}
\noindent \textbf{(P4.3)}
\begin{itemize}
\item Nous avons surchargé les opérateurs d'auto-affectation \T{+=}, \T{-=}, \T{*=} correspondant à l'addition (resp. soustraction) vectorielle et la multiplication par un scalaire. Celles-ci retournent le résultat de l'affectation pour optimiser certains calculs par la suite.

\item À partir de ces derniers nous avons surchargé les opérateurs binaires \T{+}, \T{-}, \T{*} correspondant aux opérations vectorielles usuelles.

\item Les opérateurs binaires \T{|} et \T{$\wedge$} retournent respectivement le produit scalaire euclidien et le produit vectoriel.

\item L'opérateur de comparaison \T{==} est défini à partir de la méthode \T{is\_zero()} (cf. \S1.1). L'opérateur \T{!=} retourne la négation logique de \T{==}.

\item L'opérateur d'indexage \T{[]} est surchargé pour permettre un accès direct (mais protégé) à chaque coordonnée sans devoir passer par \T{getCoords()}. Ainsi \T{u[0]}, \T{u[1]}, \T{u[2]} retourne une \textit{copie} de \T{x}, \T{y}, \T{z} respectivement. Une exception est bien-sûr lancée si l'indice n'est pas \T{0}, \T{1} ou \T{2}.
\end{itemize}

\section{La classe \T{Particle}}

\subsection{Facteur gamma, énergie}
\noindent \textbf{(P5.1)}
L'implémentation du facteur gamma et de l'énergie dans la classe \T{Particle} peut être accomplie par un attribut ou par une méthode. Chacun présente des avantages et des inconvénients.

\begin{itemize}

\item \textbf{Sous forme d'attribut:}
\subitem $\oplus$ Leur valeur serait calculée une et une seule fois, donc une même valeur ne serait jamais calculée deux fois inutilement.
\subitem $\ominus$ Leur valeur devrait être calculée systématiquement à chaque mise-à-jour de l'instance. Donc eventuellement même si elle ne servira jamais.
\subitem $\ominus$ Rajouter des attributs, c'est augmenter le poids des instances.
\subitem $\ominus$ Conceptuellement c'est un non sens ; voir ci-dessous.

\item \textbf{Sous forme de méthode:}
\subitem $\oplus$ La masse et la vitesse sont des grandeurs \textit{essentielles} d'une particule tandis que le gamma et l'énergie en découlent via des fonctions mathématiques. Conceptuellement, les attributs d'une classe devraient être reservées aux variables \textit{libres} et les méthodes aux variables \textit{liées}.

\subitem $\oplus$ Stockées sous forme de méthodes, on calcule leur valeur précisément lorsqu'on en a besoin, donc on ne stocke jamais d'information redondante.

\subitem $\ominus$ \ldots quitte à effectuer inutilement plusieurs fois le même calcul.
\end{itemize}
\bigskip
Certes, il s'agit de calculs simples avec des \double\ donc les arguments de complexité et de poids sont probablement négligeables pour un ordinateur moderne. Moyennant le pour et le contre, et en se focalisant surtout sur la clarté conceptuelle, \textbf{nous avons opté pour des méthodes.}

\section{Premiers éléments}

\subsection{Les éléments en général}
\noindent \textbf{(P6.1)} Dans la hiérarchie des classes représentant les divers éléments de l'accélérateur, nous avons mis comme nœud une classe abstraite nommée \T{Element} dont les attributs représentent les paramètres purement géométriques (points d'entrée et de sortie, rayon, paramètre de courbure) et relationnels (l'addresse de l'élément suivant, une liste des addresses des \T{Particle} contenues dans l'instance). Nous ne distinguons pas \textit{a priori} les éléments courbes des éléments droits, en sachant qu'en prenant une courbure nulle l'instance dégénère en un élément droit. Nous définissons entre autres une méthode virtuelle pure \T{add\_lorentz\_force(Particle \&p, double dt)} pour mettre en œuvre les intéractions élément-particule ; son comportement est relégué aux sous-classes suivantes:

\begin{itemize}
\item \T{Electric\_element} est une sous-classe d'\T{Element} avec un attribut supplémentaire, un champ de électrique \T{E} (dont nous discuterons de la représentation au passage suivant). Ainsi nous spécalisons la méthode \T{add\_lorentz\_force(Particle \&p)} en évaluant le champ vectoriel \T{E} au point où se trouve $\T{p}$ et en incrémentant la force résultante de \T{p} via la relation $\boldsymbol{\mathrm{F}}=q\boldsymbol{\mathrm{E}}$.

\item \T{Magnetic\_element}, quant à elle, a comme attribut supplémentaire un champ magnétique \T{B}. Dans ce cas nous spécalisons \T{add\_lorentz\_force(Particle \&p)} en évaluant $\T{B}$ en $\T{p}$ puis en appliquant la méthode relativiste $$\T{Particle::add\_magnetic\_force(const Vector3D \&B, double dt)}$$ définie auparavant dans \T{particle.h}.

\end{itemize}

\noindent Ces deux sous-classes seront ensuites spécifiées en des sous-sous-classes vraiment concrètes (e.g. dipôle) et ceci sans avoir à dupliquer à chaque fois le code correspondant à l'ajout de force sur les particules affectées.

\ \linebreak
\textbf{(P6.2)} En ce qui concerne la représentation des champs nous avons pris une approche fonctionnelle via certaines nouveautés du \T{C++11} : à savoir les \T{std::function} et les lambdas. En bref, le template \T{std::function} (fourni par l'en-tête \T{<functional>}) permet de manipuler des objets de type fonction sans indirection, et les les lambdas permettent d'instancier des fonctions génériques, \textit{inline}, et avec la possibilité ``d'attraper'' des variables dans la portée. Cela nous donne une façon légère et puissante de représenter et de manipuler des champs vectoriels (et en particulier des champs électriques ou magnétiques):
\begin{align*}
	&\T{\#include <functional>}\\
	&\T{// déclare un type pour représenter les champs vectoriels : }\\
	&\T{typedef std::function<Vector3D(const Vector3D \&)> VectorField;}\\ \\
	&\T{const Vector3D B\_0(1.0,2.0,0.0);}\\ \\
	&\T{// initialise un champ vectoriel constant via un lambda : }\\
	&\T{VectorField B = [\&](Vector3D)\{ return B\_0; \}}
\end{align*}

\noindent Bien entendu, on peut utiliser des lambdas pour instancier des champs vecteoriels non constants, et aussi compliqués que l'on souhaite.

Muni de cette représentation, l'implémentation de sous-classes spécifiques d'\T{Element} devient très concise. Il n'y a aucune méthode à redéfinir car il suffit de mettre en attribut les éventuels paramètres spécifiques de l'élément puis d'écrire le calcul du champ électrique (resp. magnétique) dans le corps d'un lambda que l'on passe en argument (parmi d'autres) au constructeur de \T{Electric\_element} (resp. \T{Magnetic\_element}).

\ \linebreak
\ \linebreak
\textbf{(P6.3)} Afin d'alléger par la suite le corps de certaines méthodes, \textbf{nous avons implémenté le calcul du centre de courbure} via la méthode \T{Element::center(void)}. Celui-ci n'a de sens que si la courbure est non nulle (i.e. l'élément est courbe) donc une exception est lancée dans le cas contraire.

\end{document}
