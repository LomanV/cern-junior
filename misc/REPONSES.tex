\documentclass[12pt, letterpaper, twoside]{article}
\usepackage[top=3cm, bottom=3cm, left=3cm, right=3cm]{geometry}
\usepackage[fleqn]{amsmath}
\usepackage{amssymb}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}

\title{Projet : fichier réponses}
\author{Raphaël Vock, Lomàn Vezin}

\newcommand{\T}[1]{\texttt{#1}}
\newcommand{\V}[0]{\texttt{Vector3D}}
\newcommand{\double}{\texttt{double}}

\begin{document}
\maketitle
\section{La classe \T{Vector3D}}
\subsection{Conception}
\noindent \textbf{(P1.1)} Les points et vecteurs de l'espace euclidien sont représentés au moyen de la classe \V\ dont les attributs \T{x}, \T{y}, \T{z} (de type \double) représentent les coordonnées cartésiennes d'une instance. Celles-ci sont des attributs privés, mais tout le reste est publique. Voici les opérations que nous avons implémentées en premier :

\begin{itemize}

\item \T{getCoords()}  est une méthode qui retourne les coordonnées d'une instance via un \T{std::array<double,3>}.

\item \T{norm()} et \T{norm2()} retournent la norme euclidienne (resp. norme euclidienne au carré).

\item \T{distance(x,y)} et \T{distance2(x,y)} sont des méthodes statiques qui retournent la distance euclidienne (resp. distance euclidienne au carré) entre deux \T{Vector3D} passés en argument.

\item \T{unitary()} est une méthode qui retourne le vecteur unitaire de même sens et de même direction (et lance une exception si l'instance est le vecteur nul ; voir point suivant).

\item \T{is\_zero()} est une méthode qui retourne un booléen indiquant si l'instance est plus petite (en norme au carré) qu'une (petite) constante de classe \T{EPSILON} de type \double.
\end{itemize}

\subsection{Constructeur, constructeur de copie}
\noindent \textbf{(P4.1)} L'unique constructeur de la classe prend en argument trois \double\ (nuls par défaut) et initialise un \V\ avec les coordonnées cartésiennes précisées. En l'absence d'attributs pointeurs, le constructeur de copie minimal par défaut réalise exactement ce que l'on attend, donc \textbf{nous n'avons pas défini de constructeur de copie.}

\subsection{Coordonnées sphériques}
\noindent \textbf{(P4.2)} \textbf{Nous n’avons pas implémenté de constructeur en coordonnées sphériques.} Avant tout, l’ajout de ce dernier serait un peu technique au niveau du prototypage de car nous aurions \textit{a priori} deux constructeurs aux protoypes identiques. Ce n'est pas un problème incontournable ; on pourrait, par exemple, écrire un seul et unique constructeur dont le quatrième argument est un \T{bool} (\T{false} par défaut) qui précise si les arguments donnés doivent être compris comme des coordonnées sphériques ou sinon cartésiennes.

Mais le problème fondamental est le suivant : un repère sphérique est intextricablement lié à la donnée d'un point $O$ considéré comme l'origine. Pour écrire un constructeur sphérique sans ambiguité il serait donc nécessaire :
\begin{itemize}
\item ou bien de faire un choix canonique de $O$ qui ne changerait pas du début à la fin
\item ou bien de préciser $O$ en le passant comme argument.
\end{itemize}
Si l'on choisit la première option, l'unique avantage des sphériques serait perdue car on ne serait plus en mesure de choisir l'origine à notre gré pour simplifier, entre autres, des expressions de force (e.g. en choisissant $O$ l'origine d'un champ de force central). Mais la deuxième option serait coûteuse à implémenter et lourde à utiliser, pour des avantages qui, selon nous, n'en vaudraient pas le coup.

\subsection{Surcharge des opérateurs}
\noindent \textbf{(P4.3)}
\begin{itemize}
\item Nous avons surchargé les opérateurs d'auto-affectation \T{+=}, \T{-=}, \T{*=} correspondant à l'addition (resp. soustraction) vectorielle et la multiplication par un scalaire. Celles-ci retournent le résultat de l'affectation pour optimiser certains calculs par la suite.

\item À partir de ces derniers nous avons surchargé les opérateurs binaires \T{+}, \T{-}, \T{*} correspondant aux opérations vectorielles usuelles.

\item Les opérateurs binaires \T{|} et \T{$\wedge$} retournent respectivement le produit scalaire euclidien et le produit vectoriel.

\item L'opérateur de comparaison \T{==} est défini à partir de la méthode \T{is\_zero()} (cf. \S1.1). L'opérateur \T{!=} retourne la négation logique de \T{==}.

\item L'opérateur d'indexage \T{[]} est surchargé pour permettre un accès direct (mais protégé) à chaque coordonnée sans devoir passer par \T{getCoords()} (cf. \S 1.1). Ainsi \T{u[0]}, \T{u[1]}, \T{u[2]} retourne une \textit{copie} de \T{x}, \T{y}, \T{z} respectivement. Une exception est bien-sûr lancée si l'indice n'est pas \T{0}, \T{1} ou \T{2}.
\end{itemize}

\section{La classe \T{Particle}}

\subsection{Facteur gamma, énergie}
\noindent \textbf{(P5.1)}
L'implémentation du facteur gamma et de l'énergie dans la classe \T{Particle} peut être accomplie par un attribut ou par une méthode. Chacun présente des avantages et des inconvénients.

\begin{itemize}

\item \textbf{Sous forme d'attribut:}
\subitem $\oplus$ Leur valeur serait calculée une et une seule fois, donc une même valeur ne serait jamais calculée deux fois inutilement.
\subitem $\ominus$ Leur valeur devrait être calculée systématiquement à chaque mise-à-jour de l'instance. Donc eventuellement même si elle ne servira jamais.
\subitem $\ominus$ Rajouter des attributs, c'est augmenter le poids des instances.
\subitem $\ominus$ Conceptuellement c'est un non sens ; voir ci-dessous.

\item \textbf{Sous forme de méthode:}
\subitem $\oplus$ La masse et la vitesse sont des grandeurs \textit{essentielles} d'une particule tandis que le gamma et l'énergie en découlent via des fonctions mathématiques. Conceptuellement, les attributs d'une classe devraient être reservées aux variables \textit{libres} et les méthodes aux variables \textit{liées}.

\subitem $\oplus$ Stockées sous forme de méthodes, on calcule leur valeur précisément lorsqu'on en a besoin, donc on ne stocke jamais d'information redondante.

\subitem $\ominus$ \ldots quitte à effectuer inutilement plusieurs fois le même calcul.
\end{itemize}
\bigskip
Certes, il s'agit de calculs simples avec des \double\ donc les arguments de complexité et de poids seront probablement négligeables à l'échelle de l'executable final. Moyennant le pour et le contre, et en se focalisant surtout sur la clarté conceptuelle, \textbf{nous avons opté pour des méthodes.}

\section{Premiers éléments}

\subsection{Les éléments en général}
\noindent \textbf{(P6.1)} Dans la hiérarchie des classes représentant les divers éléments de l'accélérateur, nous avons mis comme nœud une classe abstraite nommée \T{Element} dont les attributs représentent les paramètres purement géométriques (points d'entrée et de sortie, rayon, paramètre de courbure) et relationnels (l'addresse de l'élément suivant, une liste des addresses des \T{Particle} contenues dans l'instance) des éléments. Nous considérons les éléments comme \textit{a priori} courbes, en sachant qu'on peut prendre une courbure nulle et l'instance dégénère en un élément droit. Nous définissons entre autres une méthode virtuelle pure \T{add\_lorentz\_force(Particle \&p, double dt)} pour mettre en œuvre les intéractions élément-particule ; son comportement est délégué aux sous-classes suivantes:

\begin{itemize}
\item \T{Electric\_element} est une sous-classe d'\T{Element} avec un attribut supplémentaire, un champ de électrique \T{E} (dont nous discuterons de la représentation au passage suivant). Ainsi nous spécalisons la méthode \T{add\_lorentz\_force(Particle \&p)} en évaluant le champ vectoriel \T{E} au point où se trouve $\T{p}$ et en incrémentant la force résultante de \T{p} via la relation $\boldsymbol{\mathrm{F}}=q\boldsymbol{\mathrm{E}}$.

\item \T{Magnetic\_element}, quant à elle, a comme attribut supplémentaire un champ magnétique \T{B}. Dans ce cas nous spécalisons \T{add\_lorentz\_force(Particle \&p)} en évaluant $\T{B}$ en $\T{p}$ puis en appliquant la méthode relativiste $$\T{Particle::add\_magnetic\_force(const Vector3D \&B, double dt)}$$ déclarée auparavant dans \T{particle.h}.

\end{itemize}

\ \linebreak
\textbf{(P6.2)} Comment représenter les champs électiques/magnétiques \T{B} et \T{E} ?

La solution évidente est par des méthodes virtuelles pures, que l'on spécialise pour chaque sous-classe concrète d'\T{Element} en fonction de leur nature. Mais supposons que nous ayions envie de représenter les champs dans la sortie graphique, par exemple avec des lignes de champ. On rajouterait alors aux méthodes dessin des sous-classes d'\T{Element} le code nécessaire au traçage des lignes de champs en faisant référence aux méthodes \T{B} ou \T{E}.

Cette approche \textit{ad hoc} et très peu généralisable. Si l'on souhaite en plus visualiser d'autres champs, pas nécessairement liés aux éléments, par exemple le champ magnétique généré par une particule, on serait alors contraint à copier-coller le code lié à la représentation des lignes de champs. Ce qu'on a envie de faire, c'est déléguer la partie liée au dessin des champs de force à une fonction externe qui prend en argument un champ vectoriel et se charge de le dessiner. Mais dans le scénario que nous décrivons, les champs vectoriels sont des méthodes, donc ne peuvent pas être passés en argument !

Force est de constater que les champs vectoriels \T{B} et \T{E}, bien qu'ils aient la vocation de se comporter comme des fonctions, apparaissent conceptuellement comme des attributs : ils contiennent \textit{de l'information qui caractérise l'instance}. Par ailleurs ce sont des \textit{objets fonctionnels purs} : en les évaluant en un point on ne modifie pas l'instance. On a donc très envie de les représenter comme des \textit{attributs de classe de type fonctionnel} et non comme des méthodes.

Ceci est possible grâce au paradigme fonctionnel que propose la norme C++11, notamment avec \T{std::function} et la notation lambda. En bref :

\begin{itemize}
\item Le template \T{std::function} (fourni par l'en-tête \T{<functional>}) permet de définir des variables fonctionnelles dites ``de première classe'', c'est-à-dire qu'on peut manier comme des variables quelconques.

\item La notation lambda permet d'instancier des fonctions de première classe génériques, \textit{inline}, et avec la possibilité ``d'attraper'' des variables dans la portée.
\end{itemize}

Ensemble, ils nous procurent un puissant moyen de représenter des fonctions pures de type $\T{Vector3D} \mapsto \T{Vector3D}$ :
\begin{align*}
	&\T{\#include <functional>}\\
	&\T{// déclare une classe pour représenter les fonctions vectorielles : }\\
	&\T{typedef std::function<Vector3D(const Vector3D \&)> VectorFunction;}\\
	&\T{const Vector3D X\_0(1.0, 2.0, 0.0);}\\
	&\T{// initialise une fonction vectorielle constante via un lambda : }\\
	&\T{VectorFunction X = [](Vector3D \&)\{ return X\_0; \}}
\end{align*}

\noindent Pour représenter l'\textit{objet} correspondant au champ vectoriel nous voulons en plus qu'il ait une méthode permettant de le dessiner. On va donc encapsuler un \T{VectorFunction} dans une sous-classe de la class abstraite \T{Drawable}. Puisque le C++ donne la possibilité de surcharger l'opérateur d'appel, on peut conserver son interface ``fonctionnelle'' malgré l'encapsulation :
\begin{align*}
	&\T{class VectorField : public Drawable \{}\\
	&\indent \T{private:}\\
	& \indent \indent \T{VectorFunction F;}\\
	&\indent \T{public:}\\
	& \indent \indent \T{VectorField(VectorFunction f) : F(f)\{\}}\\
	& \indent \indent \T{// surcharge de l'opérateur d'appel :}\\
	& \indent \indent \T{Vector3D operator()(const Vector3D \&v)\ const\{ return F(v); \} }\\
	& \indent \indent \T{// prototype de la méthode pour dessiner les lignes de champ :}\\
	& \indent \indent \T{virtual draw(void) override;}\\
	& \T{\};}
\end{align*}

\indent On peut enfin définir les sous-classes \T{Electric\_field} et \T{Magnetic\_field} en rajoutant un attribut de type \T{VectorField} correspondant au champ électrique et magnétique respectivement. Munis de cette représentation, l'implémentation des sous-classes spécifiques d'\T{Element} devient très concise. À l'encontre de la première approche, nous n'avons pas à redéfinir de méthode virtuelle ; il suffit d'ajouter en attribut les éventuels paramètres spécifiques de l'élément puis d'écrire le calcul du champ électrique (resp. magnétique) dans le corps d'un lambda représentant le champ vectoriel que l'on passe en argument (parmi d'autres) au constructeur de \T{Electric\_element} (resp. \T{Magnetic\_element}).\\ \indent Illustrons ceci par la définition simplifiée de la classe dipôle (qui, rappelons-le, a un champ magnétique vertical constant et d'amplitude donnée par un paramètre) :
\begin{align*}
	&\T{class Dipole : public Magnetic\_field \{}\\
	&\indent \T{private:}\\
	& \indent \indent \T{double B\_0; // amplitude (signée) du champ constant}\\
	&\indent \T{public:}\\
	& \indent \indent \T{Dipole(parametres\_generiques, double amplitude)} :\\
	& \indent \indent \T{Magnetic\_element( // constructeur de la super-classe}\\
	& \indent \indent \indent \T{attributs\_generiques(parametres\_generiques),}\\
	& \indent \indent \indent \T{// affectation du champ via un lambda :}\\
	& \indent \indent \indent \T{B([](Vector3D \&)\{ return Vector3D(0.0, 0.0, amplitude); \} }\\
	& \indent \indent \T{),}\\
	& \indent \indent \T{B\_0(amplitude)\{\}}\\
	& \T{\};}
\end{align*}

\ \linebreak
\ \linebreak
\textbf{(P6.3)} Afin d'alléger par la suite le corps de certaines méthodes, \textbf{nous avons implémenté le calcul du centre de courbure} avec la méthode \T{Element::center(void)}. Celui-ci n'a de sens que si la courbure est non nulle (i.e. l'élément est courbe) donc une exception est lancée dans le cas contraire.

\end{document}
