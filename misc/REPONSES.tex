\documentclass[12pt, letterpaper, twoside]{article}
\usepackage[top=3cm, bottom=3cm, left=3cm, right=3cm]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}

\title{Projet : fichier réponses}
\author{Raphaël Vock, Lomàn Vezin}

\newcommand{\T}[1]{\texttt{#1}}
\newcommand{\V}[0]{\texttt{Vector3D}}
\newcommand{\double}{\texttt{double}}

\begin{document}
\maketitle
\section{La classe Vector3D}
\subsection{Conception}
\noindent \textbf{(P1.1)} Les points et vecteurs de l'espace euclidien sont représentés au moyen d'instances de la classe \V\ dont les attributs \T{x}, \T{y}, \T{z} (de type \double) sont leurs coordonnées cartésiennes. Celles-ci sont des attributs privés, mais tout le reste est publique. Voici les opérations que nous avons implémentées en premier :

\begin{itemize}

\item \T{getCoords()}  est une méthode qui retourne les coordonnées d'une instance via un \T{std::array<double,3>}.

\item \T{norm()} et \T{norm2()} retournent la norme euclidienne (resp. norme euclidienne au carré).

\item \T{distance(x,y)} et \T{distance2(x,y)} sont des méthodes statiques qui retournent la distance euclidienne (resp. distance euclidienne au carré).

\item \T{unitary()} est une méthode qui retourne le vecteur directeur de même sens et de même direction (et lance une exception si l'instance est nulle ; voir point suivant).

\item \T{is\_zero()} est une méthode qui retourne un bool indiquant si l'instance est plus petite (en norme au carré) qu'une (petite) constante \T{EPSILON}. 
\end{itemize}

\subsection{Constructeur, constructeur de copie}
\noindent \textbf{(P4.1)} L'unique constructeur de la classe prend en argument trois \double\ (nuls par défaut) et initialise un \V\ avec les coordonnées cartésiennes précisées. En l'absence d'attributs pointeurs, le constructeur de copie minimal par défaut réalise exactement ce que l'on attend, donc nous n'en avons pas defini.

\subsection{Coordonnées sphériques}
\noindent \textbf{(P4.2)} Nous n’avons pas implémenté de constructeur en coordonnées sphériques. Avant tout, l’ajout de ce dernier serait un peu technique au niveau du prototypage de car nous aurions \textit{a priori} deux constructeurs aux protoypes identiques. Ce n'est pas un problème incontournable ; on pourrait, par exemple, écrire un seul et unique constructeur dont le quatrième argument est un \T{bool} (\T{false} par défaut) qui précise si les arguments donnés doivent être compris comme des coordonnées sphériques ou sinon cartésiennes.

Mais le problème fondamental est le suivant : un repère sphérique est intextricablement lié à la donnée d'un point $O$ considéré comme l'origine. Pour écrire un constructeur sphérique sans ambiguité il serait donc nécessaire :
\begin{itemize}
\item ou bien de faire un choix canonique de $O$ qui ne changerait pas du début à la fin
\item ou bien de préciser $O$ en passant sa valeur (ou éventuellement son adresse) en argument.
\end{itemize}
Si l'on choisit la première option, l'unique avantage des sphériques serait perdue car on ne serait plus en mesure de choisir l'origine à notre gré pour simplifier, entre autres, des expressions de force (e.g. en choisissant $O$ l'origine d'un champ de force central). Mais la deuxième option serait coûteuse à implémenter et lourde à utiliser pour des avantages qui finalement n'en vaudraient pas le coup.

\subsection{Surcharge des opérateurs}
\noindent \textbf{(P4.3)}
\begin{itemize}
\item Nous avons surchargé les opérateurs d'auto-affectation \T{+=}, \T{-=}, \T{*=} correspondant à l'addition (resp. soustraction) vectorielle et la multiplication par un scalaire. Celles-ci retournent le résultat de l'affectation pour optimiser certains calculs par la suite.

\item À partir de ces derniers nous avons surchargé les opérateurs binaires \T{+}, \T{-}, \T{*}.

\item Les opérateurs binaires \T{|} et \T{$\wedge$} retournent respectivement le produit scalaire euclidien et le produit vectoriel.

\item Accessoirement, la fonction \T{mixed\_prod(u,v,w)} retourne le produit mixte des trois arguments, c'est-à-dire le scalaire \T{u|(v$\wedge$w)}.

\item L'opérateur de comparaison \T{==} est défini à partir de la méthode \T{is\_zero()} (cf. \S1.1). L'opérateur \T{!=} retourne la négation logique de \T{==};
\end{itemize}

\end{document}
