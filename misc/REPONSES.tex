\documentclass[12pt, letterpaper, twoside]{article}
\usepackage[top=3cm, bottom=3cm, left=3cm, right=3cm]{geometry}
\usepackage[fleqn]{amsmath}
\usepackage{amssymb}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}

\title{Projet : fichier réponses}
\author{Raphaël Vock, Lomàn Vezin}

\newcommand{\T}[1]{\texttt{#1}}
\newcommand{\V}[0]{\texttt{Vector3D}}
\newcommand{\double}{\texttt{double}}

\begin{document}
\maketitle
\section{La classe \T{Vector3D}}
\subsection{Conception}
\noindent \textbf{(P1.1)} Les points et vecteurs de l'espace euclidien sont représentés au moyen de la classe \V\ dont les attributs \T{x}, \T{y}, \T{z} (de type \double) représentent les coordonnées cartésiennes d'une instance. Celles-ci sont des attributs privés, mais tout le reste est publique. Voici les opérations que nous avons implémentées en premier :

\begin{itemize}

\item \T{getCoords()}  est une méthode qui retourne les coordonnées d'une instance via un \T{std::array<double,3>}.

\item \T{norm()} et \T{norm2()} retournent la norme euclidienne (resp. norme euclidienne au carré).

\item \T{distance(x,y)} et \T{distance2(x,y)} sont des méthodes statiques qui retournent la distance euclidienne (resp. distance euclidienne au carré) entre deux \T{Vector3D} passés en argument.

\item \T{unitary()} est une méthode qui retourne le vecteur unitaire de même sens et de même direction (et lance une exception si l'instance est le vecteur nul ; voir point suivant).

\item \T{is\_zero()} est une méthode qui retourne un booléen indiquant si l'instance est plus petite (en norme au carré) qu'une (petite) constante de classe \T{EPSILON} de type \double.
\end{itemize}

\subsection{Constructeur, constructeur de copie}
\noindent \textbf{(P4.1)} L'unique constructeur de la classe prend en argument trois \double\ (nuls par défaut) et initialise un \V\ avec les coordonnées cartésiennes précisées. En l'absence d'attributs pointeurs, le constructeur de copie minimal par défaut réalise exactement ce que l'on attend, donc \textbf{nous n'avons pas défini de constructeur de copie.}

\subsection{Coordonnées sphériques}
\noindent \textbf{(P4.2)} \textbf{Nous n’avons pas implémenté de constructeur en coordonnées sphériques.} Avant tout, l’ajout de ce dernier serait un peu technique au niveau du prototypage de car nous aurions \textit{a priori} deux constructeurs aux protoypes identiques. Ce n'est pas un problème incontournable ; on pourrait, par exemple, écrire un seul et unique constructeur dont le quatrième argument est un \T{bool} (\T{false} par défaut) qui précise si les arguments donnés doivent être compris comme des coordonnées sphériques ou sinon cartésiennes.

Mais le problème fondamental est le suivant : un repère sphérique est intextricablement lié à la donnée d'un point $O$ considéré comme l'origine. Pour écrire un constructeur sphérique sans ambiguité il serait donc nécessaire :
\begin{itemize}
\item ou bien de faire un choix canonique de $O$ qui ne changerait pas du début à la fin
\item ou bien de préciser $O$ en le passant comme argument.
\end{itemize}
Si l'on choisit la première option, l'unique avantage des sphériques serait perdue car on ne serait plus en mesure de choisir l'origine à notre gré pour simplifier, entre autres, des expressions de force (e.g. en choisissant $O$ l'origine d'un champ de force central). Mais la deuxième option serait coûteuse à implémenter et lourde à utiliser, pour des avantages qui, selon nous, n'en vaudraient pas le coup.

\subsection{Surcharge des opérateurs}
\noindent \textbf{(P4.3)}
\begin{itemize}
\item Nous avons surchargé les opérateurs d'auto-affectation \T{+=}, \T{-=}, \T{*=} correspondant à l'addition (resp. soustraction) vectorielle et la multiplication par un scalaire. Celles-ci retournent le résultat de l'affectation pour optimiser certains calculs par la suite.

\item À partir de ces derniers nous avons surchargé les opérateurs binaires \T{+}, \T{-}, \T{*} correspondant aux opérations vectorielles usuelles.

\item Les opérateurs binaires \T{|} et \T{$\wedge$} retournent respectivement le produit scalaire euclidien et le produit vectoriel.

\item L'opérateur de comparaison \T{==} est défini à partir de la méthode \T{is\_zero()} (cf. \S1.1). L'opérateur \T{!=} retourne la négation logique de \T{==}.

\item L'opérateur d'indexage \T{[]} est surchargé pour permettre un accès direct (mais protégé) à chaque coordonnée sans devoir passer par \T{getCoords()} (cf. \S 1.1). Ainsi \T{u[0]}, \T{u[1]}, \T{u[2]} retourne une \textit{copie} de \T{x}, \T{y}, \T{z} respectivement. Une exception est bien-sûr lancée si l'indice n'est pas \T{0}, \T{1} ou \T{2}.
\end{itemize}

\section{La classe \T{Particle}}

\subsection{Facteur gamma, énergie}
\noindent \textbf{(P5.1)}
L'implémentation du facteur gamma et de l'énergie dans la classe \T{Particle} peut être accomplie par un attribut ou par une méthode. Chacun présente des avantages et des inconvénients.

\begin{itemize}

\item \textbf{Sous forme d'attribut:}
\subitem $\oplus$ Leur valeur serait calculée une et une seule fois, donc une même valeur ne serait jamais calculée deux fois inutilement.
\subitem $\ominus$ Leur valeur devrait être calculée systématiquement à chaque mise-à-jour de l'instance. Donc eventuellement même si elle ne servira jamais.
\subitem $\ominus$ Rajouter des attributs, c'est augmenter le poids des instances.
\subitem $\ominus$ Conceptuellement c'est un non sens ; voir ci-dessous.

\item \textbf{Sous forme de méthode:}
\subitem $\oplus$ La masse et la vitesse sont des grandeurs \textit{essentielles} d'une particule tandis que le gamma et l'énergie en découlent via des fonctions mathématiques. Conceptuellement, les attributs d'une classe devraient être reservées aux variables \textit{libres} et les méthodes aux variables \textit{liées}.

\subitem $\oplus$ Stockées sous forme de méthodes, on calcule leur valeur précisément lorsqu'on en a besoin, donc on ne stocke jamais d'information redondante.

\subitem $\ominus$ \ldots quitte à éventuellement effectuer plusieurs fois le même calcul.
\end{itemize}
\bigskip
Certes, il s'agit de calculs simples avec des \double\ donc les arguments de complexité et de poids seront probablement négligeables à l'échelle de l'executable final. Moyennant le pour et le contre, et en se focalisant surtout sur la clarté conceptuelle, \textbf{nous avons opté pour des méthodes.}

\section{Premiers éléments}

\subsection{Les éléments en général}
\noindent \textbf{(P6.1)} Dans la hiérarchie des classes représentant les divers éléments de l'accélérateur, nous avons mis comme nœud une classe abstraite nommée \T{Element} dont les attributs représentent les paramètres purement géométriques (points d'entrée et de sortie, rayon, paramètre de courbure) et relationnels (l'addresse de l'élément suivant, une liste des addresses des \T{Particle} contenues dans l'instance) des éléments. Nous considérons les éléments comme \textit{a priori} courbes, en sachant qu'on peut prendre une courbure nulle et l'instance dégénère en un élément droit. Nous définissons entre autres une méthode virtuelle pure \T{add\_lorentz\_force(Particle \&p, double dt)} pour mettre en œuvre les intéractions élément-particule ; son comportement est délégué aux sous-classes suivantes:

\begin{itemize}
\item \T{Electric\_element} est une sous-classe d'\T{Element} avec un attribut supplémentaire, un champ de électrique \T{E} (dont nous discuterons de la représentation au passage suivant). Ainsi nous spécalisons la méthode \T{add\_lorentz\_force(Particle \&p)} en évaluant le champ vectoriel \T{E} au point où se trouve $\T{p}$ et en incrémentant la force résultante de \T{p} via la relation $\boldsymbol{\mathrm{F}}=q\boldsymbol{\mathrm{E}}$.

\item \T{Magnetic\_element}, quant à elle, a comme attribut supplémentaire un champ magnétique \T{B}. Dans ce cas nous spécalisons \T{add\_lorentz\_force(Particle \&p)} en évaluant $\T{B}$ en $\T{p}$ puis en appliquant la méthode relativiste $$\T{Particle::add\_magnetic\_force(const Vector3D \&B, double dt)}$$ déclarée auparavant dans \T{particle.h}.

\end{itemize}

\ \linebreak
\textbf{(P6.2)} Comment représenter les champs électiques/magnétiques \T{B} et \T{E} ?

La solution évidente est par des méthodes virtuelles pures, que l'on spécialise pour chaque sous-classe concrète d'\T{Element} en fonction de leur nature. Mais supposons que nous ayions envie de représenter les champs dans la sortie graphique, par exemple avec des lignes de champ. On rajouterait alors aux méthodes dessin des sous-classes d'\T{Element} le code nécessaire au traçage des lignes de champs en faisant référence aux méthodes \T{B} ou \T{E}.

Cette approche \textit{ad hoc} et très peu généralisable. Si l'on souhaite en plus visualiser d'autres champs, pas nécessairement liés aux éléments, par exemple le champ magnétique généré par une particule, on serait alors contraint à copier-coller le code lié à la représentation des lignes de champs. Ce qu'on a envie de faire, c'est déléguer la partie liée au dessin des champs de force à une fonction externe qui prend en argument un champ vectoriel et se charge de le dessiner. Mais dans le scénario que nous décrivons, les champs vectoriels sont des méthodes, donc ne peuvent pas être passés en argument !

Force est de constater que les champs vectoriels \T{B} et \T{E}, bien qu'ils aient la vocation de se comporter comme des fonctions, apparaissent conceptuellement comme des attributs : ils contiennent \textit{de l'information qui caractérise l'instance}. Par ailleurs ce sont des \textit{objets fonctionnels purs} : en les évaluant en un point on ne modifie pas l'instance. On a donc très envie de les représenter comme des \textit{attributs de type fonctionnel} et non comme des méthodes.

Ceci est possible grâce au paradigme fonctionnel que propose la norme C++11, notamment avec \T{std::function} et la notation lambda. Pour rappel :

\begin{itemize}
\item Le template \T{std::function} (fourni par l'en-tête \T{<functional>}) permet de définir des variables fonctionnelles dites ``de première classe'', c'est-à-dire qu'on peut manier comme des variables quelconques.

\item La notation lambda permet d'instancier des fonctions de première classe génériques, \textit{inline}, et avec la possibilité ``d'attraper'' des variables dans la portée.
\end{itemize}

Ensemble, ils nous procurent un puissant moyen de représenter des fonctions pures de type $\T{Vector3D} \mapsto \T{Vector3D}$ :
\begin{align*}
	&\T{\#include <functional>}\\
	&\T{// déclare une classe pour représenter les fonctions vectorielles : }\\
	&\T{typedef std::function<Vector3D(const Vector3D \&)> vector\_function;}\\
	&\T{const Vector3D X\_0(1.0, 2.0, 0.0);}\\
	&\T{// initialise une fonction vectorielle constante via un lambda : }\\
	&\T{vector\_function X = [](Vector3D \&)\{ return X\_0; \}}
\end{align*}

\noindent Pour représenter l'\textit{objet} correspondant au champ vectoriel nous voulons en plus qu'il ait une méthode permettant de le dessiner. On va donc encapsuler un \T{vector\_function} dans une sous-classe de la class abstraite \T{Drawable}. Puisque le C++ donne la possibilité de surcharger l'opérateur d'appel, on peut conserver son interface ``fonctionnelle'' malgré l'encapsulation :
\begin{align*}
	&\T{class VectorField : public Drawable \{}\\
	&\indent \T{private:}\\
	& \indent \indent \T{vector\_function F;}\\
	&\indent \T{public:}\\
	& \indent \indent \T{VectorField(vector\_function f) : F(f)\{\}}\\
	& \indent \indent \T{// surcharge de l'opérateur d'appel :}\\
	& \indent \indent \T{Vector3D operator()(const Vector3D \&v)\ const\{ return F(v); \} }\\
	& \indent \indent \T{// prototype de la méthode pour dessiner les lignes de champ :}\\
	& \indent \indent \T{virtual void draw(void) override;}\\
	& \T{\};}
\end{align*}

\indent On peut enfin définir les sous-classes \T{Electric\_field} et \T{Magnetic\_field} en rajoutant un attribut de type \T{VectorField} correspondant au champ électrique et magnétique respectivement. Munis de cette représentation, l'implémentation des sous-classes spécifiques d'\T{Element} devient très concise. À l'encontre de la première approche, nous n'avons pas à redéfinir de méthode virtuelle ; il suffit d'ajouter en attribut les éventuels paramètres spécifiques de l'élément puis d'écrire le calcul du champ électrique (resp. magnétique) dans le corps d'un lambda représentant le champ vectoriel que l'on passe en argument (parmi d'autres) au constructeur de \T{Electric\_element} (resp. \T{Magnetic\_element}).\\ \indent Illustrons ceci par la définition simplifiée de la classe représentant les dipôles (qui, rappelons-le, ont un champ magnétique vertical constant, d'amplitude donnée par un paramètre) :
\begin{align*}
	&\T{class Dipole : public Magnetic\_field \{}\\
	&\indent \T{private:}\\
	& \indent \indent \T{double B\_0; // amplitude (signée) du champ constant}\\
	&\indent \T{public:}\\
	& \indent \indent \T{Dipole(parametres\_generiques, double amplitude)} :\\
	& \indent \indent \T{Magnetic\_element( // constructeur de la super-classe}\\
	& \indent \indent \indent \T{attributs\_generiques(parametres\_generiques),}\\
	& \indent \indent \indent \T{// affectation du champ via un lambda :}\\
	& \indent \indent \indent \T{B([](Vector3D \&)\{ return Vector3D(0.0, 0.0, amplitude); \} }\\
	& \indent \indent \T{),}\\
	& \indent \indent \T{B\_0(amplitude)\{\}}\\
	& \T{\};}
\end{align*}

\ \linebreak
\ \linebreak
\textbf{(P6.3)} Afin d'alléger par la suite le corps de certaines méthodes, \textbf{nous avons implémenté le calcul du centre de courbure} avec la méthode \T{Element::center(void)}. Celui-ci n'a de sens que si la courbure est non nulle (i.e. l'élément est courbe) donc une exception est lancée dans le cas contraire.

\section{La classe \T{Accelerator}}

\subsection{Conception}

\ \linebreak
\noindent \textbf{(P7.1)} La classe \T{Accelerator} \emph{est} par héritage \T{private} une collection de pointeurs sur des \T{Element}, c'est d'ailleurs ce schéma que nous adoptons pour la conception de la majorité de nos classes. Un accélérateur contient un \T{shared\_ptr} sur un timer, faisant office de chronomètre commun à tous les éléments composant l'accélérateur, ce qui se revèle utile pour les éléments dont le champ dépend du temps comme la \T{RadiofrequencyCavity}. Enfin pour sa construction un accélérateur contient une origne, vue comme un \T{Vector3D}, ainsi qu'une longueur (0 par défaut). Concrètement les différents éléments de l'accélérateur sont "soudés" par la méthode \T{weld()} qui lie chaque élément à son succésseur et prédecesseur.

\ \linebreak
\noindent \textbf{(P7.2)} Nous avons supprimé le constructeur de copie par défaut ainsi que l'opérateur d'afféctation \T{=} de la classe \T{Accelerator} pour garantir l'intégrité des ses données. Cette classe contient en effet une liste de pointeurs intelligents sur des éléments \T{vector<unique\_ptr><Element> >}. Bien que nous puissions effectuer une telle copie en faisant une copie profonde des éléments de la liste, nous considérons que cette solution a peu de sens et nous n'en aurions quand bien même pas l'utilité. 

\subsection{Révision des éléments}

\ \linebreak
\noindent \textbf{(P8.1)} La méthode \T{has\_collided()} de la classe \T{Element} doit se comporter de façon différente si elle est appelée sur un élément courbe ou sur un élément droit. Dans une première approche il s'agirait donc en terme de programation orientée objet d'une méthode virtuelle. Toutefois afin d'éviter une duplication inutile du code et par soucis de conception, nous avons fais le choix de représenter les éléments droits comme des éléments courbe de courbure nulle, en remarquant que toutes les méthodes appliquées à ces éléments sont les mêmes que celles appliquées aux élements courbes lorsque la courbure tend vers 0.

\ \linebreak
\noindent \textbf{(P8.2)} Si la méthode \T{has\_collided()} était virtuelle, on s'attendrait à ce qu'ell soit virtuelle pure puisqu'on ne saurait la définir dans le cas d'un élément qui ne soit ni courbe si droit, faisant de la classe \T{Element} une classe abstraite. Ce n'est cependant pas le cas dans notre conception des éléments puisque nous voyons les éléments droits comme des élements de courbure nulle. La classe \T{Element} n'a pas besoin d'être abstraite.

\section{Conception du système}

\subsection{Objets dessinables}

\ \linebreak
\noindent \textbf{(P9.1)} La méthode \T{draw()} a un comportement différent selon le \T{Canvas} qu'elle doit dessiner, il s'agit donc d'une méthode virtuelle.

\ \linebreak
\noindent \textbf{(P9.2)} La classe \T{Accelerator} est, par héritage privé, une collection d'éléments et possède une collection de \T{Particle} plus tard remplacées par des \T{Beam}, les faisceaux. On souhaite que la méthode \T{draw()} s'applique à chacun des éléments et chacune des particules selon les caractéristiques propres à l'instance. Nous avons donc besoin, dans un cadre de programation orientée objet, de \emph{polymorphisme} et plus précisément de résolution dynamique des liens. La classe \T{Accelerator} doit donc être une collection de pointeurs sur des \T{Element} et contenir une collection de pointeurs sur des \T{Beam}. 

\ \linebreak
\noindent \textbf{(P9.3)} Nous devons à présent être vigilants vis à vis de la copie puisque notre classe contient des pointeurs. Une solution serait de redéfinir le constructeur de copie ainsi que l'opérateur d'affectation \T{=} en implémentant une copie \emph{profonde} et non de surface afin de garantir l'intégrité des données. Toutefois nous ne souhaitons pas copier d'accélerateur, ce qui aurait d'ailleurs peu d'utilité et de sens, nous supprimons simplement ce constructeur et l'opérateur \T{=} avec le mot réservé \T{delete}. 

\section{La classe \T{Beam}}

\subsection{Conception}

\ \linebreak
\noindent \textbf{(P11.1)} Un \T{Beam}, ou faisceau, est par héritage \T{private}, une collection de \T{Particle}. Ses attributs, constants, sont une référence sur la particule modèle du faisceau, le nombre de macroparticules crées \T{N}, le facteur $\lambda$ de ces macroparticules ainsi qu'un pointeur sur l'accélérateur dans lequel l'instance évolue. Puisque l'émittance, radiale et verticale, ainsi que les six coefficients des ellipses de phases et l'énergie moyenne du faisceau seront recalculés fréquemment nous avons décidé de les implementer comme méthodes. 

The matrix is invertible

\end{document}
