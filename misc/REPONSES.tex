\documentclass[12pt, letterpaper, twoside]{article}
\usepackage[top=3cm, bottom=3cm, left=3cm, right=3cm]{geometry}
\usepackage[fleqn]{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{shapes,decorations}
\usepackage{comment}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}

\title{Projet: fichier réponses}
\author{Raphaël Vock, Lomàn Vezin}

\newcommand{\T}[1]{\texttt{#1}}
\newcommand{\V}[0]{\texttt{Vector3D}}
\newcommand{\double}{\texttt{double}}

\begin{document}
\maketitle
\section{La classe \T{Vector3D}}
\subsection{Conception}
\noindent \textbf{(P1.1)} Les points et vecteurs de l'espace euclidien sont représentés au moyen de la classe \V\ dont les attributs \T{x}, \T{y}, \T{z} (de type \double) représentent les coordonnées cartésiennes d'une instance. Celles-ci sont des attributs privés, mais tout le reste est publique. Voici les opérations que nous avons implémentées en premier :

\begin{itemize}

\item \T{getCoords()}  est une méthode qui retourne les coordonnées d'une instance via un \T{std::array<double,3>}.

\item \T{norm()} et \T{norm2()} retournent la norme euclidienne (resp. norme euclidienne au carré).

\item \T{distance(x,y)} et \T{distance2(x,y)} sont des méthodes statiques qui retournent la distance euclidienne (resp. distance euclidienne au carré) entre deux \T{Vector3D} passés en argument.

\item \T{unitary()} est une méthode qui retourne le vecteur unitaire de même sens et de même direction (et lance une exception si l'instance est le vecteur nul ; voir point suivant).

\item \T{is\_zero()} est une méthode qui retourne un booléen indiquant si l'instance est plus petite (en norme au carré) qu'une (petite) constante de classe \T{EPSILON} de type \double.
\end{itemize}

\subsection{Constructeur, constructeur de copie}
\noindent \textbf{(P4.1)} L'unique constructeur de la classe prend en argument trois \double\ (nuls par défaut) et initialise un \V\ avec les coordonnées cartésiennes précisées. En l'absence d'attributs pointeurs, le constructeur de copie minimal par défaut réalise exactement ce que l'on attend, donc \textbf{nous n'avons pas défini de constructeur de copie.}

\subsection{Coordonnées sphériques}
\noindent \textbf{(P4.2)} \textbf{Nous n’avons pas implémenté de constructeur en coordonnées sphériques.} Avant tout, l’ajout de ce dernier serait un peu technique au niveau du prototypage de car nous aurions \textit{a priori} deux constructeurs aux protoypes identiques. Ce n'est pas un problème incontournable ; on pourrait, par exemple, écrire un seul et unique constructeur dont le quatrième argument est un \T{bool} (\T{false} par défaut) qui précise si les arguments donnés doivent être compris comme des coordonnées sphériques ou sinon cartésiennes.

Mais le problème fondamental est le suivant : un repère sphérique est intextricablement lié à la donnée d'un point $O$ considéré comme l'origine. Pour écrire un constructeur sphérique sans ambiguité il serait donc nécessaire :
\begin{itemize}
\item ou bien de faire un choix canonique de $O$ qui ne changerait pas du début à la fin
\item ou bien de préciser $O$ en le passant comme argument.
\end{itemize}
Si l'on choisit la première option, l'unique avantage des sphériques serait perdue car on ne serait plus en mesure de choisir l'origine à notre gré pour simplifier, entre autres, des expressions de force (e.g. en choisissant $O$ l'origine d'un champ de force central). Mais la deuxième option serait coûteuse à implémenter et lourde à utiliser, pour des avantages qui, selon nous, n'en vaudraient pas le coup.

\subsection{Surcharge des opérateurs}
\noindent \textbf{(P4.3)}
\begin{itemize}
\item Nous avons surchargé les opérateurs d'auto-affectation \T{+=}, \T{-=}, \T{*=} correspondant à l'addition (resp. soustraction) vectorielle et la multiplication par un scalaire. Celles-ci retournent le résultat de l'affectation pour optimiser certains calculs par la suite.

\item À partir de ces derniers nous avons surchargé les opérateurs binaires \T{+}, \T{-}, \T{*} correspondant aux opérations vectorielles usuelles.

\item Les opérateurs binaires \T{|} et \T{$\wedge$} retournent respectivement le produit scalaire euclidien et le produit vectoriel.

\item L'opérateur de comparaison \T{==} est défini à partir de la méthode \T{is\_zero()} (cf. \S1.1). L'opérateur \T{!=} retourne la négation logique de \T{==}.

\item L'opérateur d'indexage \T{[]} est surchargé pour permettre un accès direct (mais protégé) à chaque coordonnée sans devoir passer par \T{getCoords()} (cf. \S 1.1). Ainsi \T{u[0]}, \T{u[1]}, \T{u[2]} retourne une \textit{copie} de \T{x}, \T{y}, \T{z} respectivement. Une exception est bien-sûr lancée si l'indice n'est pas \T{0}, \T{1} ou \T{2}.
\end{itemize}

\section{La classe \T{Particle}}

\subsection{Facteur gamma, énergie}
\noindent \textbf{(P5.1)}
L'implémentation du facteur gamma et de l'énergie dans la classe \T{Particle} peut être accomplie par un attribut ou par une méthode. Chacun présente des avantages et des inconvénients.

\begin{itemize}

\item \textbf{Sous forme d'attribut:}
\subitem $\oplus$ Leur valeur serait calculée une et une seule fois, donc une même valeur ne serait jamais calculée deux fois inutilement.
\subitem $\ominus$ Leur valeur devrait être calculée systématiquement à chaque mise-à-jour de l'instance. Donc eventuellement même si elle ne servira jamais.
\subitem $\ominus$ Rajouter des attributs, c'est augmenter le poids des instances.

\item \textbf{Sous forme de méthode:}
\subitem $\oplus$ La masse et la vitesse sont des grandeurs \textit{essentielles} d'une particule tandis que le gamma et l'énergie en découlent via des fonctions mathématiques. Conceptuellement, les attributs d'une classe devraient être reservées aux variables \textit{libres} et les méthodes aux variables \textit{liées}.

\subitem $\oplus$ Stockées sous forme de méthodes, on calcule leur valeur précisément lorsqu'on en a besoin, donc on ne stocke jamais d'information redondante.

\subitem $\ominus$ \ldots quitte à éventuellement effectuer plusieurs fois le même calcul.
\end{itemize}
\bigskip
\textit{A priori} ses grandeurs seront accédés plusieurs fois par mise à jour de l'accélérateur. C'est pourquoi nous avons décidé de les implémenter sous forme d'attribut.

\section{Premiers éléments}

\subsection{Les éléments en général}
\noindent \textbf{(P6.1)} Dans la hiérarchie des classes représentant les divers éléments de l'accélérateur, nous avons mis comme nœud une classe abstraite nommée \T{Element} dont les attributs représentent les paramètres purement géométriques (points d'entrée et de sortie, rayon, paramètre de courbure) et relationnels (l'addresse de l'élément suivant, une liste des addresses des \T{Particle} contenues dans l'instance) des éléments. Nous considérons les éléments comme \textit{a priori} courbes, en sachant qu'on peut prendre une courbure nulle et l'instance dégénère en un élément droit. Nous définissons entre autres une méthode virtuelle pure \T{apply\_lorentz\_force(Particle \&p, double dt)} pour mettre en œuvre les intéractions élément-particule ; son comportement est délégué aux sous-classes suivantes:

\begin{itemize}
\item \T{Electric\_element} est une sous-classe d'\T{Element} avec un attribut supplémentaire, un champ de électrique \T{E} (dont nous discuterons de la représentation au passage suivant). Ainsi nous spécialisons la méthode \T{apply\_lorentz\_force(Particle \&p)} en évaluant le champ vectoriel \T{E} au point où se trouve $\T{p}$ et en incrémentant la force résultante de \T{p} via la relation $\boldsymbol{\mathrm{F}}=q\boldsymbol{\mathrm{E}}$.

\item \T{Magnetic\_element}, quant à elle, a comme attribut supplémentaire un champ magnétique \T{B}. Dans ce cas nous spécialisons \T{add\_lorentz\_force(Particle \&p)} en évaluant $\T{B}$ en $\T{p}$ puis en appliquant la méthode relativiste $$\T{Particle::add\_magnetic\_force(const Vector3D \&B, double dt)}$$ déclarée auparavant dans \T{particle.h}.

\end{itemize}

\ \linebreak
\textbf{(P6.2)} Comment représenter les champs magnétiques ?

Comme expliqué ci-dessus, les champs magnétiques sont des méthodes virtuelles pures qui prennent en argument un point de l'espace, et retournent la valeur du champ vectoriel en se point.

\ \linebreak
\ \linebreak
\textbf{(P6.3)} Afin d'alléger par la suite le corps de certaines méthodes, \textbf{nous avons implémenté le calcul du centre de courbure} avec la méthode \T{Element::center(void)}. Celui-ci n'a de sens que si la courbure est non nulle (i.e. l'élément est courbe) donc une exception est lancée dans le cas contraire.

\ \linebreak
\textbf{(P6.4)} La relation d'appartenance entre une particule et l'élément dans lequel elle se trouve se manifeste par un attribut \T{Element* current\_element}. Ceci implique directement qu'une particule ne peut appartenir qu'à un et un seul élément.

\section{La classe \T{Accelerator}}

\subsection{Généralités}
\noindent \textbf{(P7.1)} Un accélérateur \textit{est} une collection d'éléments donc nous faisons hériter la classe \T{Accelerator} de \T{std::vector<std::unique\_ptr<Element>>}. Nous passons par des \T{unique\_ptr} pour obtenir un comportement polymorphe des éléments. Par ailleurs, cette héritage est \T{private} pour rester en accord avec la norme C++.

Énumérons les principaux attributs et méthodes de cette classe :
\begin{itemize}
	\item L'attribut \T{std::vector<std::unique\_ptr<Particle>> particles} stockera les particules contenues dans l'accélérateur. Nous utilisons à nouveau des \T{unique\_ptr} pour pouvoir avoir un comportement polymorphe si le besoin se présente.
	\item L'attribut \T{const Vector3D origin} définit un point de repère sur l'accélérateur et servira à faciliter la construction de l'accélérateur.
	\item L'attribut \T{double length} décrit la longueur géométrique de l'accélérateur. Celui-ci aidera à définir un système de coordonnées curviligne global sur la longeur de l'accélérateur.
	\item La méthode \T{void addParticle(const \&Particle)} permet d'insérer une particule dans l'accélérateur \textit{tout en conservant la nature de l'instance s'il s'agit d'une sous-classe.}
	\item Pour chaque sous-classe concrète \T{E} de \T{Element} nous avons une méthode \T{addE} permettant d'ajouter une instance de cette sous-classe à l'accélérateur. Cette méthode prend en arguments un point de l'espace ainsi que les divers paramètres géométriques et physiques de l'élément en question. L'unique point correspond au point de sortie de l'élément ; le point d'entrée est déduit comme étant le point de sortie du précédent (ou sinon \T{origin} s'il n'y en a pas).
\end{itemize}

\ \linebreak
\noindent \textbf{(P7.2)} Nous avons supprimé le constructeur de copie par défaut ainsi que l'opérateur d'afféctation \T{=} de la classe \T{Accelerator} pour garantir l'intégrité des ses données. Cette classe contient en effet une liste de pointeurs intelligents sur des éléments \T{vector<unique\_ptr><Element> >}. Bien que nous puissions effectuer une telle copie en faisant une copie profonde des éléments de la liste, nous considérons que cette solution a peu de sens et nous n'en aurions quand bien même pas l'utilité.

\subsection{Révision des éléments}

\ \linebreak
\noindent \textbf{(P8.1)} La méthode \T{has\_collided()} de la classe \T{Element} doit se comporter de façon différente si elle est appelée sur un élément courbe ou sur un élément droit. Dans une première approche il s'agirait donc en terme de programation orientée objet d'une méthode virtuelle. Toutefois afin d'éviter une duplication inutile du code et par soucis de conception, nous avons fais le choix de représenter les éléments droits comme des éléments courbe de courbure nulle, en remarquant que toutes les méthodes appliquées à ces éléments sont les mêmes que celles appliquées aux élements courbes lorsque la courbure tend vers 0.

\ \linebreak
\noindent \textbf{(P8.2)} Si la méthode \T{has\_collided()} était virtuelle, on s'attendrait à ce qu'ell soit virtuelle pure puisqu'on ne saurait la définir dans le cas d'un élément qui ne soit ni courbe si droit, faisant de la classe \T{Element} une classe abstraite. Ce n'est cependant pas le cas dans notre conception des éléments puisque nous voyons les éléments droits comme des élements de courbure nulle. La classe \T{Element} n'a pas besoin d'être abstraite.

\section{Conception du système}

\subsection{Objets dessinables}

\ \linebreak
\noindent \textbf{(P9.1)} La méthode \T{draw()} a un comportement différent selon le \T{Canvas} qu'elle doit dessiner, il s'agit donc d'une méthode virtuelle.

\ \linebreak
\noindent \textbf{(P9.2)} La classe \T{Accelerator} est, par héritage privé, une collection d'éléments et possède une collection de \T{Particle} plus tard remplacées par des \T{Beam}, les faisceaux. On souhaite que la méthode \T{draw()} s'applique à chacun des éléments et chacune des particules selon les caractéristiques propres à l'instance. Nous avons donc besoin, dans un cadre de programation orientée objet, de \emph{polymorphisme} et plus précisément de résolution dynamique des liens. La classe \T{Accelerator} doit donc être une collection de pointeurs sur des \T{Element} et contenir une collection de pointeurs sur des \T{Beam}. 

\ \linebreak
\noindent \textbf{(P9.3)} Nous devons à présent être vigilants vis à vis de la copie puisque notre classe contient des pointeurs. Une solution serait de redéfinir le constructeur de copie ainsi que l'opérateur d'affectation \T{=} en implémentant une copie \emph{profonde} et non de surface afin de garantir l'intégrité des données. Toutefois nous ne souhaitons pas copier d'accélerateur, ce qui aurait d'ailleurs peu d'utilité et de sens, nous supprimons simplement ce constructeur et l'opérateur \T{=} avec le mot réservé \T{delete}. L'utilisation de pointeurs nous force de plus à faire attention au destructeur de la classe. Puisque nous utilisons des pointeurs intelligents nous n'avons pas besoin de nous préocupper de la gestion de mémoire (\T{delete}) car celle ci s'effectue automatiquement. 

\section{La classe \T{Beam}}

\subsection{Conception}

\ \linebreak
\noindent \textbf{(P11.1)} Un \T{Beam}, ou faisceau, est par héritage \T{private}, une collection de \T{Particle}. Ses attributs, constants, sont une référence sur la particule modèle du faisceau, le nombre de macroparticules crées \T{N}, le facteur $\lambda$ de ces macroparticules ainsi qu'un pointeur sur l'accélérateur dans lequel l'instance évolue. Puisque l'émittance, radiale et verticale, ainsi que les six coefficients des ellipses de phases et l'énergie moyenne du faisceau seront recalculés fréquemment nous avons décidé de les implementer comme méthodes. 

\newpage
\section{Hiérarchie des classes}\noindent
Ci-dessous deux schémas représentant les hiérarchies relationnelles des classes.

\subsection{Légende}
\begin{tikzpicture}[transform shape,mylabel/.style={thin, draw=black, align=center, minimum width=0.5cm, minimum height=0.5cm,fill=white,font=\normalsize}]
\node (L0) at (0,0) {};
\node (R0) at (3.5,0) {};
\node (T0) at (3.5,0) [label=right: hérite de] {};

\node (L1) at (0,-1) {};
\node (R1) at (3.5,-1) {};
\node (T1) at (3.5,-1) [label=right: hérite de \textit{via} \T{template<>}] {};

\node (L2) at (0,-2) {};
\node (R2) at (3.5,-2) {};
\node (T2) at (3.5,-2) [label=right: contient une ou plusieurs instances de] {};

\node (L3) at (0,-3) {};
\node (R3) at (3.5,-3) {};
\node (T3) at (3.5,-3) [label=right: contient un ou plusieurs pointeurs vers des instances de] {};

\draw
(L0) edge [->] (R0)
(L1) edge [->] node[mylabel] {\T{template<>}} (R1)
(L2) edge [->, red] (R2)
(L3) edge [->, red, dashed] (R3);

\end{tikzpicture}

\subsection{Des classes liées aux objets de la simulation}
\begin{tikzpicture}[transform shape,mylabel/.style={thin, draw=black, align=center, minimum width=0.5cm, minimum height=0.5cm,fill=white,font=\normalsize}]

\node (P0) at (2,0) {\T{Vector3D}};
\node (P1) at (2,-3) {\T{PointCharge}}; 
\node (P9) at (2, -6) {\T{Particle}};
\node (P3) at (12, -10.5) {\T{Beam}};
\node (P4) at (12, 0) {\T{Accelerator}};
\node (P6) at (12, -4) {\T{Element}};
\node (P7) at (12, -7.32) {\T{Node}};
\node (P8) at (7.5, -7.32) {\T{Box}};

\draw
(P4) edge [->] node[mylabel] {\T{vector<unique\_ptr<>\,>}} (P6)
(P3) edge [-> , bend left = 20] node[mylabel] {\T{std::vector<unique\_ptr<unique\_ptr<>\,>\,>}} (P9.south)

(P7) edge [-> , loop right, dashed, red] (P7.south)
(P6) edge [-> , loop right, dashed, red] (P6.south)
(P4) edge [-> , red] (P0)
(P1) edge [->] (P0)
(P9) edge [->] (P1)
(P6) edge [->] (P7)
(P7) edge [-> , red] (P8)
(P4) edge [-> , dashed, red] (P9)
(P6.west) edge [-> , red] (P0)
(P7) edge [-> , red] (P1.south east)
(P8) edge [-> , red] (P0)
(P9) edge [-> , bend left = 60, red] (P0)
(P4.south east) edge [-> , bend left = 60, dashed, red] (P3.north)
(P3) edge [-> , bend left = -60, dashed, red] (P4.east);

\end{tikzpicture}

\subsection{Des classes liées à la représentation de la simulation}

\begin{tikzpicture}
\node (P0) at (4.5,0) {\T{Drawable}};
\node (P1) at (13.5,0) {\T{Canvas}};
\node (P2) at (9,-2) {\T{Element}};
\node (P3) at (12, -2) {\T{TextView}};
\node (P4) at (15, -2) {\T{OpenGLView}};
\node (P5) at (6,-2) {\T{Accelerator}};
\node (P6) at (3,-2) {\T{Particle}};
\node (P7) at (0,-2) {\T{Box}};
\node (P8) at (10.5,-6) {\T{ConsoleWidget}};
\node (P9) at (10.5,-4.5) {\T{GLWidget}};

\path [->]
(P0) edge [dashed, red] (P1)
(P2) edge (P0)
(P5) edge (P0)
(P6) edge (P0)
(P7) edge (P0)
(P3) edge (P1)
(P4) edge (P1)
(P8) edge (P4)
(P9) edge (P3)
(P8) edge (P5)
(P9) edge (P5.south east);
\end{tikzpicture}

\ \linebreak
\ \linebreak

\end{document}
